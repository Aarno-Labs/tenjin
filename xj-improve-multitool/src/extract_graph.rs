use std::collections::HashMap;
use std::collections::HashSet;

use rustc_hir::{
    self as hir, ForeignItem, HirId, Item, ItemKind,
    def::Res,
    def_id::DefId,
    intravisit::{self, Visitor},
};
use rustc_middle::ty::TyCtxt;
use rustc_session::config::CrateType;

use petgraph::graph::DiGraph;

pub fn extract_def_graph(tcx: TyCtxt<'_>) -> ExtractedGraphData {
    let is_binary: bool = tcx
        .crate_types()
        .iter()
        .any(|ty| matches!(ty, CrateType::Executable));

    let mut visitor = GraphExtractionVisitor {
        tcx,
        is_binary,
        graf: DefGraph::new(),
        defspans: HashMap::new(),
        top_item_defs: HashSet::new(),
        all_fn_defs: HashSet::new(),
        scope: Vec::new(),
    };
    tcx.hir_walk_toplevel_module(&mut visitor);

    ExtractedGraphData {
        graf: visitor.graf,
        defspans: visitor.defspans,
        all_fn_defs: visitor.all_fn_defs,
        top_item_defs: visitor.top_item_defs,
    }
}

pub struct ExtractedGraphData {
    pub graf: DefGraph,
    pub defspans: HashMap<DefId, rustc_span::Span>,
    pub all_fn_defs: HashSet<DefId>,
    pub top_item_defs: HashSet<DefId>,
}

pub struct DefGraph {
    pub graf: DiGraph<GNode, GEdge>,
    pub grafnodes: HashMap<GNode, petgraph::graph::NodeIndex>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GNode {
    Def(DefId),
    VirtualRoot,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GEdge {
    /// If function foo calls bar, then the graph will have a
    /// (foo, bar, Mentions) triple.
    Mentions,
    /// If item foo is defined in module bar, then the graph will have a
    /// (foo, bar, Inhabits) triple (whereas one might otherwise expect
    /// (bar, foo, Mentions)).
    Inhabits,
}

impl DefGraph {
    pub fn new() -> Self {
        let mut g = DefGraph {
            graf: DiGraph::new(),
            grafnodes: HashMap::new(),
        };
        let _ = g.add_node(GNode::VirtualRoot);
        g
    }

    fn add_node(&mut self, node: GNode) -> petgraph::graph::NodeIndex {
        match self.grafnodes.get(&node) {
            Some(idx) => *idx,
            None => {
                let idx = self.graf.add_node(node);
                self.grafnodes.insert(node, idx);
                idx
            }
        }
    }

    pub fn update_edge(&mut self, a: GNode, b: GNode, edge: GEdge) {
        let a_idx = self.add_node(a);
        let b_idx = self.add_node(b);
        self.graf.update_edge(a_idx, b_idx, edge);
    }
}

struct GraphExtractionVisitor<'c> {
    tcx: TyCtxt<'c>,
    is_binary: bool,
    graf: DefGraph,
    defspans: HashMap<DefId, rustc_span::Span>,
    top_item_defs: HashSet<DefId>,
    all_fn_defs: HashSet<DefId>,
    scope: Vec<hir::OwnerId>,
}

impl GraphExtractionVisitor<'_> {
    fn saw_item_like(
        &mut self,
        item_def: DefId,
        item_span: rustc_span::Span,
        vis_span: rustc_span::Span,
    ) {
        if !item_span.data().ctxt.is_root() {
            // A non-root syntax context occurs, for example, when the item has
            // been generated by a derive macro, and the span we have points
            // within the derive attribute.
            //
            // Return before putting anything in the graph because we don't want
            // to end up erasing individual components of the derive.
            return;
        }

        self.defspans.insert(item_def, item_span);

        match self.scope.last() {
            Some(direct_owner) => {
                self.graf.update_edge(
                    GNode::Def(item_def),
                    GNode::Def(direct_owner.to_def_id()),
                    GEdge::Inhabits,
                );
            }
            None => {
                // We explicitly add nodes for items so that the graph contains nodes
                // even for items with no incoming or outgoing edges.
                let _ = self.graf.add_node(GNode::Def(item_def));

                self.top_item_defs.insert(item_def);
            }
        }

        let src_map = self.tcx.sess.source_map();
        if self.is_binary {
            // In a binary crate, most identifiers are dead if not explicitly referenced,
            // but items marked `#[no_mangle]` could be referenced by a companion library crate.
            // If we remove such a referenced item, `cargo check` would pass but
            // `cargo build` would fail with missing symbol errors during linking.
            //
            // Eventually we should collect the set of actually-referenced symbols.
            // For now, we conservatively retain all `#[no_mangle]` items.
            if let Ok(line_info) = src_map.lookup_line(item_span.lo()) {
                if line_info.line == 0 {
                    // No preceding line
                } else if let Some(preceding_line) = line_info.sf.get_line(line_info.line - 1) {
                    if preceding_line.trim_start().starts_with("#[no_mangle]") {
                        self.graf.update_edge(
                            GNode::VirtualRoot,
                            GNode::Def(item_def),
                            GEdge::Mentions,
                        );
                    }
                }
            }
        } else {
            // In a library crate, `pub` items must be considered live.
            if src_map.span_to_snippet(vis_span) == Ok("pub".to_string()) {
                self.graf
                    .update_edge(GNode::VirtualRoot, GNode::Def(item_def), GEdge::Mentions);
            }
        }
    }
}

impl<'c> Visitor<'c> for GraphExtractionVisitor<'c> {
    type NestedFilter = rustc_middle::hir::nested_filter::All;

    fn maybe_tcx(&mut self) -> Self::MaybeTyCtxt {
        self.tcx
    }

    fn visit_item(&mut self, item: &'c Item<'c>) -> Self::Result {
        match item.kind {
            ItemKind::Use(_, _) => {
                // Fixing up use items is tricky. With source syntax like
                // `use foo::bar::{Baz, Quxx};` we'll have two uses, but the
                // associated spans will only cover Baz and Quux, so if we
                // simply erase the spans, we'll end up with invalid source.
                // Dropping dead uses isn't really something we need to handle
                // ourselves, since `cargo fix` will do it for us.
                //
                // ALSO, identifying actually-dead uses requires considering
                // trait requirements, etc. Just because a module is not mentioned
                // doesn't mean it's dead!
                return intravisit::walk_item(self, item);
            }
            ItemKind::Fn { .. } => {
                self.all_fn_defs.insert(item.owner_id.to_def_id());
            }
            _ => {}
        }

        self.saw_item_like(item.owner_id.to_def_id(), item.span, item.vis_span);

        self.scope.push(item.owner_id);
        intravisit::walk_item(self, item);
        self.scope.pop();
    }

    fn visit_foreign_item(&mut self, item: &'c ForeignItem<'c>) -> Self::Result {
        self.saw_item_like(item.owner_id.to_def_id(), item.span, item.vis_span);

        self.scope.push(item.owner_id);
        intravisit::walk_foreign_item(self, item);
        self.scope.pop();
    }

    fn visit_path(&mut self, path: &hir::Path<'c>, _id: HirId) -> Self::Result {
        match path.res {
            Res::Def(_defkind, def_id) => {
                if let Some(direct_owner) = self.scope.last() {
                    self.graf.update_edge(
                        GNode::Def(direct_owner.to_def_id()),
                        GNode::Def(def_id),
                        GEdge::Mentions,
                    );
                } else {
                    // eprintln!(
                    //     "Visiting unscoped path with defkind {:?} and def_id: {:?}",
                    //     _defkind, def_id
                    // );
                }
            }
            Res::SelfCtor(_def_id) => {
                // We ignore this case because c2rust doesn't generate it.
            }
            Res::Local(_hir_id) => {
                // References to locals cannot affect top-level item liveness/deadness.
            }
            Res::PrimTy(_)
            | Res::ToolMod
            | Res::NonMacroAttr(_)
            | Res::SelfTyParam { .. }
            | Res::SelfTyAlias { .. }
            | Res::Err => (),
        }

        intravisit::walk_path(self, path)
    }
}
