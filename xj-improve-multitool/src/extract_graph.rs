use std::collections::HashMap;
use std::collections::HashSet;

use rustc_hir::{
    self as hir,
    def::Res,
    def_id::DefId,
    intravisit::{self, Visitor},
    ForeignItem, HirId, Item, ItemKind,
};
use rustc_middle::ty::TyCtxt;
use rustc_session::config::CrateType;

use petgraph::graph::DiGraph;

pub fn extract_def_graph(tcx: TyCtxt<'_>) -> ExtractedGraphData {
    let is_binary: bool = tcx
        .crate_types()
        .iter()
        .any(|ty| matches!(ty, CrateType::Executable));

    let mut visitor = GraphExtractionVisitor {
        tcx,
        is_binary,
        graf: DefGraph::new(),
        defspans: HashMap::new(),
        top_item_defs: HashSet::new(),
        scope: Vec::new(),
    };
    tcx.hir_walk_toplevel_module(&mut visitor);

    ExtractedGraphData {
        graf: visitor.graf,
        defspans: visitor.defspans,
        top_item_defs: visitor.top_item_defs,
    }
}

pub struct ExtractedGraphData {
    pub graf: DefGraph,
    pub defspans: HashMap<DefId, rustc_span::Span>,
    pub top_item_defs: HashSet<DefId>,
}

pub struct DefGraph {
    pub graf: DiGraph<GNode, GEdge>,
    pub grafnodes: HashMap<GNode, petgraph::graph::NodeIndex>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GNode {
    Def(DefId),
    VirtualRoot,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GEdge {
    /// If function foo calls bar, then the graph will have a
    /// (foo, bar, Mentions) triple.
    Mentions,
    /// If item foo is defined in module bar, then the graph will have a
    /// (foo, bar, Inhabits) triple (whereas one might otherwise expect
    /// (bar, foo, Mentions)).
    Inhabits,
}

impl DefGraph {
    pub fn new() -> Self {
        let mut g = DefGraph {
            graf: DiGraph::new(),
            grafnodes: HashMap::new(),
        };
        let _ = g.add_node(GNode::VirtualRoot);
        g
    }

    fn add_node(&mut self, node: GNode) -> petgraph::graph::NodeIndex {
        match self.grafnodes.get(&node) {
            Some(idx) => *idx,
            None => {
                let idx = self.graf.add_node(node);
                self.grafnodes.insert(node, idx);
                idx
            }
        }
    }

    pub fn update_edge(&mut self, a: GNode, b: GNode, edge: GEdge) {
        let a_idx = self.add_node(a);
        let b_idx = self.add_node(b);
        self.graf.update_edge(a_idx, b_idx, edge);
    }
}

struct GraphExtractionVisitor<'c> {
    tcx: TyCtxt<'c>,
    is_binary: bool,
    graf: DefGraph,
    defspans: HashMap<DefId, rustc_span::Span>,
    top_item_defs: HashSet<DefId>,
    scope: Vec<hir::OwnerId>,
}

impl GraphExtractionVisitor<'_> {
    fn saw_item_like(
        &mut self,
        item_def: DefId,
        item_span: rustc_span::Span,
        vis_span: rustc_span::Span,
    ) {
        if !item_span.data().ctxt.is_root() {
            // A non-root syntax context occurs, for example, when the item has
            // been generated by a derive macro, and the span we have points
            // within the derive attribute.
            //
            // Return before putting anything in the graph because we don't want
            // to end up erasing individual components of the derive.
            return;
        }

        self.defspans.insert(item_def, item_span);

        match self.scope.last() {
            Some(direct_owner) => {
                self.graf.update_edge(
                    GNode::Def(item_def),
                    GNode::Def(direct_owner.to_def_id()),
                    GEdge::Inhabits,
                );
            }
            None => {
                // We explicitly add nodes for items so that the graph contains nodes
                // even for items with no incoming or outgoing edges.
                let _ = self.graf.add_node(GNode::Def(item_def));

                self.top_item_defs.insert(item_def);
            }
        }

        if !self.is_binary {
            let vis_text = self
                .tcx
                .sess
                .source_map()
                .span_to_snippet(vis_span)
                .unwrap_or_else(|_| "<no snippet>".to_string());
            if vis_text == "pub" {
                self.graf
                    .update_edge(GNode::VirtualRoot, GNode::Def(item_def), GEdge::Mentions);
            }
        }
    }
}

impl<'c> Visitor<'c> for GraphExtractionVisitor<'c> {
    type NestedFilter = rustc_middle::hir::nested_filter::All;

    fn maybe_tcx(&mut self) -> Self::MaybeTyCtxt {
        self.tcx
    }

    fn visit_item(&mut self, item: &'c Item<'c>) -> Self::Result {
        if let ItemKind::Use(_, _) = item.kind {
            // Fixing up use items is tricky. With source syntax like
            // `use foo::bar::{Baz, Quxx};` we'll have two uses, but the
            // associated spans will only cover Baz and Quux, so if we
            // simply erase the spans, we'll end up with invalid source.
            // Dropping dead uses isn't really something we need to handle
            // ourselves, since `cargo fix` will do it for us.
            //
            // ALSO, identifying actually-dead uses requires considering
            // trait requirements, etc. Just because a module is not mentioned
            // doesn't mean it's dead!
            return intravisit::walk_item(self, item);
        }

        self.saw_item_like(item.owner_id.to_def_id(), item.span, item.vis_span);

        self.scope.push(item.owner_id);
        let res = intravisit::walk_item(self, item);
        self.scope.pop();
        res
    }

    fn visit_foreign_item(&mut self, item: &'c ForeignItem<'c>) -> Self::Result {
        self.saw_item_like(item.owner_id.to_def_id(), item.span, item.vis_span);

        self.scope.push(item.owner_id);
        let res = intravisit::walk_foreign_item(self, item);
        self.scope.pop();
        res
    }

    fn visit_path(&mut self, path: &hir::Path<'c>, _id: HirId) -> Self::Result {
        match path.res {
            Res::Def(_defkind, def_id) => {
                if let Some(direct_owner) = self.scope.last() {
                    self.graf.update_edge(
                        GNode::Def(direct_owner.to_def_id()),
                        GNode::Def(def_id),
                        GEdge::Mentions,
                    );
                } else {
                    // eprintln!(
                    //     "Visiting unscoped path with defkind {:?} and def_id: {:?}",
                    //     _defkind, def_id
                    // );
                    ()
                }
            }
            Res::SelfCtor(_def_id) => {
                // We ignore this case because c2rust doesn't generate it.
                ()
            }
            Res::Local(_hir_id) => {
                // References to locals cannot affect top-level item liveness/deadness.
                ()
            }
            Res::PrimTy(_)
            | Res::ToolMod
            | Res::NonMacroAttr(_)
            | Res::SelfTyParam { .. }
            | Res::SelfTyAlias { .. }
            | Res::Err => (),
        }

        intravisit::walk_path(self, path)
    }
}
